C     $Id$
C
C     ***** INITIALIZE AK-EQ INTERFACE *****
C
      SUBROUTINE AKEQIN(KNAMEQ1,NRMAX1,NTHMAX1,NSUMAX1,
     &                  ALPMAX,RAXIS1,ZAXIS1,IERR)
C
      INCLUDE '../eq/eqcomq.inc'
      CHARACTER KNAMEQ1*80
      SAVE INIT
      DATA INIT/0/
C
      IF(INIT.EQ.0) THEN
         CALL EQINIT
         CALL EQPARM(1,'eqparm',IERR)
         INIT=1
      ENDIF
C
      MDLEQC=1
      NRMAX=NRMAX1
      NTHMAX=NTHMAX1
      NSUMAX=NSUMAX1
C
      IERR=0
      CALL EQLOAD(3,KNAMEQ1,IERR)
      IF(IERR.NE.0) RETURN
C
      write(LINE,'(A,I5)') 'nrmax=',NRMAX
      call eqparm(3,line,ierr)
      write(LINE,'(A,I5)') 'nthmax=',NTHMAX
      call eqparm(3,line,ierr)
      write(LINE,'(A,I5)') 'nsumax=',NSUMAX
      call eqparm(3,line,ierr)
      CALL EQCALQ(IERR)
      IF(IERR.NE.0) RETURN
      ALPMAX=FNPSIT(1.D0)
      CALL GETAXS(RAXIS1,ZAXIS1)
C
      CALL EQCALA(IERR)
C      CALL AKTEST
      RETURN
      END
C
C     ***** TEST *****
C
      SUBROUTINE AKTEST
C
      INCLUDE '../eq/eqcomq.inc'
C
      ALPHAMAX=PSIT(NRPMAX)
      DELA=0.2D0*ALPHAMAX
      DELTH=2.D0*PI/4.D0
      DO NR=1,5
         ALPHA=DELA*NR
         BETA=0.D0
         CALL ABTORZ(ALPHA,BETA,R0,Z0,IERR)
         BETA=DELTH
         CALL ABTORZ(ALPHA,BETA,R1,Z1,IERR)
         BETA=2*DELTH
         CALL ABTORZ(ALPHA,BETA,R2,Z2,IERR)
         BETA=3*DELTH
         CALL ABTORZ(ALPHA,BETA,R3,Z3,IERR)
         BETA=4*DELTH
         CALL ABTORZ(ALPHA,BETA,R4,Z4,IERR)
         WRITE(6,'(I5,1P6E12.4)') NR,ALPHA,R0,R1,R2,R3,R4
         WRITE(6,'(I5,1P6E12.4)') NR,BETA,Z0,Z1,Z2,Z3,Z4
         WRITE(6,*)
      ENDDO
      RETURN
      END
C
C     ***** INITIALIZE RZ-AB CONVERSION *****
C
      SUBROUTINE EQCALA(IERR)
C
      USE libspl2d
      INCLUDE '../eq/eqcomq.inc'
      COMMON /EQAKV1/ SALPHG(NRM),BETAG(NTHMP)
      COMMON /EQAKV2/ UABR(4,4,NTHMP,NRM),UABZ(4,4,NTHMP,NRM)
      DIMENSION RPSA(NTHMP,NRM),RPSB(NTHMP,NRM),RPSAB(NTHMP,NRM)
      DIMENSION ZPSA(NTHMP,NRM),ZPSB(NTHMP,NRM),ZPSAB(NTHMP,NRM)
C
      DTH=2.D0*PI/NTHMAX
      DO NR=1,NRMAX
         SALPHG(NR)=SQRT(PSIT(NR))
      ENDDO
      DO NTH=1,NTHMAX+1
         BETAG(NTH)=DTH*(NTH-1)
      ENDDO
C
      CALL SPL2D(BETAG,SALPHG,RPS,RPSB,RPSA,RPSAB,UABR,
     &           NTHMP,NTHMAX+1,NRMAX,4,0,IERR)
      IF(IERR.NE.0) THEN
         IERR=IERR+10000
         RETURN
      ENDIF
C
      CALL SPL2D(BETAG,SALPHG,ZPS,ZPSB,ZPSA,ZPSAB,UABZ,
     &           NTHMP,NTHMAX+1,NRMAX,4,0,IERR)
      IF(IERR.NE.0) THEN
         IERR=IERR+20000
         RETURN
      ENDIF
C
      RETURN
      END
C
C     ***** CONVERSION (R,Z) to (Alpha,Beta) *****
C
      SUBROUTINE RZTOAB(R,Z,ALPHA,BETA)
C
      USE libbrent
      USE libspl1d
      INCLUDE '../eq/eqcomq.inc'
      COMMON /EQAKF1/ ALPHAF1,RF1,ZF1
      EXTERNAL FNBETA
C
      PSIPL=PSIG(R,Z)-PSI0
      CALL SPL1DF(PSIPL,PSITL,PSIP,UPSIT,NRMAX,IERR)
      IF(PSITL.LT.0.D0) PSITL=0.D0
      ALPHA=PSITL
      ALPHAF1=ALPHA
      RF1=R
      ZF1=Z
C
      EPSZ=1.D-8
      BETAIN=ATAN2((Z-ZAXIS)/RKAP,R-RAXIS)
      BETA=FBRENT(FNBETA,BETAIN-1.5D0,BETAIN+1.5D0,EPSZ)
      IF(BETA.LT.0.D0)    BETA=BETA+2.D0*PI
      IF(BETA.GT.2.D0*PI) BETA=BETA-2.D0*PI
      RETURN
      END
C
C     ----- FNBETA=0 FOR BETA CLOSEST TO (RF1,ZF1) FOR FIXED ALPHA
C
      FUNCTION FNBETA(BETA)
C
      INCLUDE '../eq/eqcomq.inc'
      COMMON /EQAKF1/ ALPHAF1,RF1,ZF1
C
      DBETA=1.D-6
      ALPHA1=ALPHAF1
      BETA1=BETA+0.5D0*DBETA
      CALL ABTORZ(ALPHA1,BETA1,R1,Z1,IERR)
      FN1=(R1-RF1)**2+(Z1-ZF1)**2
      BETA2=BETA-0.5D0*DBETA
      CALL ABTORZ(ALPHA1,BETA2,R2,Z2,IERR)
      FN2=(R2-RF1)**2+(Z2-ZF1)**2
      FNBETA=(FN2-FN1)/DBETA
C      WRITE(6,'(A,1P5E11.3)') 
C     &     'BETA,R1,Z1,FN1,FNBETA=',BETA,R1,Z1,FN1,FNBETA
C      CALL GUFLSH
      RETURN
      END
C
C     ***** CONVERSION (Alpha,Beta) TO (R,Z) *****
C
      SUBROUTINE ABTORZ(ALPHA,BETA,R,Z,IERR)
C
      USE libspl2d
      INCLUDE '../eq/eqcomq.inc'
      COMMON /EQAKV1/ SALPHG(NRM),BETAG(NTHMP)
      COMMON /EQAKV2/ UABR(4,4,NTHMP,NRM),UABZ(4,4,NTHMP,NRM)
C
      IERR=0
      ALPHAL=ALPHA
      IF(BETA.LT.0.D0) THEN
         BETAL=BETA+2.D0*PI
      ELSEIF(BETA.GT.2.D0*PI) THEN
         BETAL=BETA-2.D0*PI
      ELSE
         BETAL=BETA
      ENDIF
      CALL SPL2DF(BETAL,SQRT(ALPHAL),R,
     &            BETAG,SALPHG,UABR,NTHMP,NTHMAX+1,NRMAX,IERR)
      IF(IERR.NE.0) THEN
         IERR=IERR+10000
         RETURN
      ENDIF
      CALL SPL2DF(BETAL,SQRT(ALPHAL),Z,
     &            BETAG,SALPHG,UABZ,NTHMP,NTHMAX+1,NRMAX,IERR)
      IF(IERR.NE.0) THEN
         IERR=IERR+20000
         RETURN
      ENDIF
      RETURN
      END
C
C     ***** CALCULATE dR/dalpha, dR/dbeta *****
C
      SUBROUTINE DRDAB_EQ (ALPHA, BETA, DRDA, DRDB)
C
      USE libspl2d
      INCLUDE '../eq/eqcomq.inc'
      COMMON /EQAKV1/ SALPHG(NRM),BETAG(NTHMP)
      COMMON /EQAKV2/ UABR(4,4,NTHMP,NRM),UABZ(4,4,NTHMP,NRM)
C     
      ALPHAL = ALPHA
      BETAL = BETA
      CALL SPL2DD(BETAL,SQRT(ALPHAL),R,DRDB,DRDA,
     &     BETAG,SALPHG,UABR,NTHMP,NTHMAX+1,NRMAX,IERR)
      DRDA = DRDA / (2.d0 * SQRT(ALPHA))
C
      RETURN
      END
C
C     ***** CALCULATE dZ/dalpha, dZ/dbeta *****
C
      SUBROUTINE DZDAB_EQ (ALPHA, BETA, DZDA, DZDB)
C
      USE libspl2d
      INCLUDE '../eq/eqcomq.inc'
      COMMON /EQAKV1/ SALPHG(NRM),BETAG(NTHMP)
      COMMON /EQAKV2/ UABR(4,4,NTHMP,NRM),UABZ(4,4,NTHMP,NRM)
C     
      ALPHAL = ALPHA
      BETAL = BETA
      CALL SPL2DD(BETAL,SQRT(ALPHAL),Z,DZDB,DZDA,
     &     BETAG,SALPHG,UABZ,NTHMP,NTHMAX+1,NRMAX,IERR)

      DZDA = DZDA / (2.d0 * SQRT(ALPHA))
C
      RETURN
      END
C
C     ***** INTERPOLATE FUNCTIONS *****
C
      FUNCTION PSIP_EQ(ALPHA)
C
      USE libspl1d
      INCLUDE '../eq/eqcomq.inc'
C
      PSITL=ALPHA
      CALL SPL1DF(PSITL,PSIPL,PSIT,UPSIT,NRMAX,IERR)
C      IF(IERR.NE.0) WRITE(6,*) 'XX PSIP_EQ: SPL1DF ERROR : IERR=',IERR
      PSIP_EQ=PSIPL / (2.d0 * PI)
      RETURN
      END
C
C     ***** CALCULATE q AND dq/dalpha, p *****
C
      SUBROUTINE SUBQPA(ALPHA,Q,DQDA,P)
C
      USE libspl1d
      INCLUDE '../eq/eqcomq.inc'
      real*8 ppl
C
      RHOTL=SQRT(ALPHA/PSITA)
      DPSIL=2.d0 * SQRT(ALPHA * PSITA)
C
C     r = sqrt(a/amax)
C
C     dq       1    dq        1         dq
C     -- = -------- -- = -------------- --
C     dr   2 r amax da   2 sqrt(a amax) da
C
C
      CALL SPL1DD(RHOTL,QPL,DQPL,RHOT,UQPS,NRMAX,IERR)
      IF(IERR.NE.0) WRITE(6,*) 'XX SUBQPA: SPL1DD ERROR2 : IERR=',IERR
      Q=QPL
      IF(DPSIL.EQ.0.D0) THEN
         DQDA=0.D0
      ELSE
         DQDA=DQPL/DPSIL
      ENDIF
      CALL SPL1DF(RHOTL,PPL,RHOT,UPPS,NRMAX,IERR)
      IF(IERR.NE.0) WRITE(6,*) 'XX SUBQPA: SPL1DF ERROR3 : IERR=',IERR
      P=PPL
      RETURN
      END
C
C     ***** CALCULATE Bmax AND dBmax/dalpha *****
C
      SUBROUTINE SUBBMX(ALPHA,BMX,DBMXDA)
C
      USE libspl1d
      INCLUDE '../eq/eqcomq.inc'
C
      PSITL=ALPHA
      RHOTL=SQRT(PSITL/PSITA)
      CALL SPL1DD(PSITL,PSIPL,DPSIPL,PSIT,UPSIT,NRMAX,IERR)
      IF(IERR.NE.0) WRITE(6,*) 'XX SUBBMX: SPL1DD ERROR1 : IERR=',IERR
      CALL SPL1DD(RHOTL,BBMAXL,DBBMAXL,RHOT,UBBMAX,NRMAX,IERR)
      IF(IERR.NE.0) WRITE(6,*) 'XX SUBBMX: SPL1DD ERROR2 : IERR=',IERR
      BMX=BBMAXL
      IF(DPSIPL.EQ.0.D0) THEN
         DBMXDA=0.D0
      ELSE
         DBMXDA=DBBMAXL/DPSIPL
      ENDIF
      RETURN
      END
C
C     ***** CALCULATE Bmin AND dBmin/dalpha *****
C
      SUBROUTINE SUBBMN(ALPHA,BMN,DBMNDA)
C
      USE libspl1d
      INCLUDE '../eq/eqcomq.inc'
C
      PSITL=ALPHA
      RHOTL=SQRT(PSITL/PSITA)
      CALL SPL1DD(PSITL,PSIPL,DPSIPL,PSIT,UFTT,NRMAX,IERR)
      IF(IERR.NE.0) WRITE(6,*) 'XX SUBBMN: SPL1DD ERROR1 : IERR=',IERR
      CALL SPL1DD(RHOTL,BBMINL,DBBMINL,RHOT,UBBMIN,NRMAX,IERR)
      IF(IERR.NE.0) WRITE(6,*) 'XX SUBBMN: SPL1DD ERROR2 : IERR=',IERR
      BMN=BBMINL
      IF(DPSIPL.EQ.0.D0) THEN
         DBMNDA=0.D0
      ELSE
         DBMNDA=DBBMINL/DPSIPL
      ENDIF
      RETURN
      END
C
C     ***** CALCULATE MAGNETIC FIELD *****
C
      SUBROUTINE SUBMAG(ALPHA,BETA,BR,BZ,BT,BTOT,AJR,AJZ,AJT)
C
      USE libspl1d
      USE libspl2d
      INCLUDE '../eq/eqcomq.inc'
C
      CALL ABTORZ(ALPHA,BETA,RP,ZP,IERR)
C      WRITE(6,'(A,1P2E12.4,I5)') 'RP,ZP,IERR=',RP,ZP,IERR
C      IF(IERR.NE.0) WRITZE(6,*) 
C     &        'XX BTOTAB: ABTORZ ERROR : IERR=',IERR
C
      CALL SPL2DD(RP,ZP,PSIL,PSIR,PSIZ,
     &            RG,ZG,UPSIRZ,NRGM,NRGMAX,NZGMAX,IERR)
C      WRITE(6,'(A,1P3E12.4,I5)') 
C     &     'PSIL,PSIR,PSIZ,IERR=',PSIL,PSIR,PSIZ,IERR
      IF(IERR.NE.0) WRITE(6,*) 
     &        'XX BTOTAB: SPL2DD ERROR : IERR=',IERR
      CALL SPL2DF(RP,ZP,HJTL,
     &            RG,ZG,UHJTRZ,NRGM,NRGMAX,NZGMAX,IERR)
      IF(IERR.NE.0) WRITE(6,*) 
     &        'XX BTOTAB: SPL2DF ERROR : IERR=',IERR
C
      RHOTL=SQRT(ALPHA/PSITA)
      CALL SPL1DD(RHOTL,TTL,DTTL,RHOT,UTTS,NRMAX,IERR)
      IF(IERR.NE.0) WRITE(6,*) 
     &        'XX BTOTAB: SPL1DF ERROR : IERR=',IERR
C
      CALL SPL1DF(RHOTL,QPL,RHOT,UQPS,NRMAX,IERR)
      IF(IERR.NE.0) WRITE(6,*) 
     &        'XX BTOTAB: SPL1DF ERROR : IERR=',IERR
C
      BT= TTL/(2.D0*PI*RP)
      BR=-PSIZ/(2.D0*PI*RP)
      BZ= PSIR/(2.D0*PI*RP)
      BTOT=SQRT(BT**2+BR**2+BZ**2)
      IF(RHOTL.EQ.0.D0) THEN
         DTTDPSIP=0.D0
      ELSE
         DTTDPSIP=QPL*DTTL/(RMU0*2.D0*PSITA*RHOTL)
      ENDIF
      AJR=BR*DTTDPSIP
      AJZ=BZ*DTTDPSIP
      AJT=HJTL
C
C      WRITE(6,'(A,1P4E12.4)') 'RP,ZP,PSIL,TTL=',RP,ZP,PSIL,TTL
C      WRITE(6,'(A,1P4E12.4)') 'BR,BZ,BT,BTOT=',BR,BZ,BT,BTOT
C      WRITE(6,'(A,1P3E12.4)') 'AJR,AJZ,AJT  =',AJR,AJZ,AJT
      RETURN
      END
